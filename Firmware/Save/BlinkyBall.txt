// BlinkyBall.c
// firmware for BlinkBall by Dataman for SynShop.Org
// 4/26/12 - Initial Version
//           Based on TinyCylon2.C by Dale Wheat
// notes:
// device = ATtiny13A
// clock = 128 KHz internal RC oscillator
// max ISP frequency ~20 KHz
// brown-out detect = 1.8 V

#include <avr/io.h>
#include <avr/interrupt.h>

// These registers are available on the ATtiny13A but not the original ATtiny13
// Brown out detector control register

#define BODCR _SFR_IO8(0x30)
#define BODSE 0
#define BODS 1

// Power reduction register
#define PRR _SFR_IO8(0x3C)
#define PRADC 0
#define PRTIM0 1

// Counter
volatile unsigned char downcounter;


volatile MODE mode __attribute__ ((section (".noinit")));

///////////////////////////////////////////////////////////////////////////////
// init() - initialize everything
// note:  this "function" is in section .init3 so it is executed before main()
///////////////////////////////////////////////////////////////////////////////

void init(void) __attribute__ ((naked, section(".init3")));
void init(void) {

	// turn off unused peripherals to save power
	ACSR = 0<<ACD; // disable analog comparator
	DIDR0 = 0<<ADC3D | 1<<ADC2D | 1<<ADC1D | 1<<ADC0D | 1<<AIN1D | 1<<AIN0D; // enable ADC3


	// initialize ATtiny13 input & output port

	// PORTB

	//	PB0		5		MOSI/AIN0/OC0A/PCINT0		D1 output, R, active low
	//	PB1		6		MISO/AIN1/OC0B/INT0/PCINT1	D2 output, G, active low
	//	PB2		7		SCK/ADC1/T0/PCINT2		D3 output, B, active low
	//	PB3		2		PCINT3/CLKI/ADC3		NC Random Noice Input
	//	PB4		3		PCINT4/ADC2		        NC
	//	PB5		1		PCINT5/-RESET/ADC0/dW		MODE TILT SWITCH, active low

	PORTB = 0<<PORTB5 | 0<<PORTB4 | 0<<PORTB3 | 1<<PORTB2 | 1<<PORTB1 | 1<<PORTB0;
	DDRB = 0<<DDB5 | 0<<DDB4 | 0<<DDB3 | 1<<DDB2 | 1<<DDB1 | 1<<DDB0;

	// initialize ATtiny13 timer/counter

	TCCR0B = 0<<FOC0A | 0<<FOC0B | 0<<WGM02 | 0<<CS02 | 0<<CS01 | 1<<CS00;
	TIMSK0 = 0<<OCIE0B | 0<<OCIE0A | 1<<TOIE0; // interrupts

	// turn off unused peripherals to save power
	ACSR = 1<<ACD; // disable analog comparator
	DIDR0 = 1<<ADC3D | 1<<ADC2D | 1<<ADC1D | 1<<ADC0D | 1<<AIN1D | 1<<AIN0D; // disable digital inputs

	sei(); // enable global interrupts
}

///////////////////////////////////////////////////////////////////////////////
// timing & delay functions
///////////////////////////////////////////////////////////////////////////////


void delay(unsigned char n) {

	downcounter = n;

	while(downcounter) {
		MCUCR = 1<<PUD | 1<<SE | 0<<SM1 | 0<<SM0 | 0<<ISC01 | 0<<ISC00; // idle mode
		asm("sleep"); // go to sleep to save power
	}
}


void main(void) {
			delay(255);

			PORTB = 0b00000111; // all LEDs off
			while(1) {
				// deepest sleep mode
				cli(); // disable interrupts
				PRR = 1<<PRTIM0 | 1<<PRADC; // power down timer/counter0 & ADC
				BODCR = 1<<BODS | 1<<BODSE; // enable BOD disable during sleep, step 1
				BODCR = 1<<BODS | 0<<BODSE; // step 2
				MCUCR = 1<<PUD | 1<<SE | 1<<SM1 | 0<<SM0 | 0<<ISC01 | 0<<ISC00; // select "power down" mode
				asm("sleep"); // go to sleep to save power
			}
}

///////////////////////////////////////////////////////////////////////////////
// timer/counter0 overflow interrupt handler
///////////////////////////////////////////////////////////////////////////////

ISR(TIM0_OVF_vect) {

	downcounter--; // decrement downcounter for delay functions
}

///////////////////////////////////////////////////////////////////////////////

// [end-of-file]
